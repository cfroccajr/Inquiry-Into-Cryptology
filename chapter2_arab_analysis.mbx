<?xml version="1.0" encoding="UTF-8" ?>

<!--********************************************************************
Copyright 2017 Charles F. Rocca Jr

This file is part of a MathBook XML project.

This project is focused on creating a brief inquiry based text for 
use in a introductory course in cryptology for non-technical students.  
The material is presented, whenever possible, in a historically honest 
manner.

Copyright 2015 Robert A. Beezer

This file is part of MathBook XML.

MathBook XML is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 or version 3 of the
License (at your option).

MathBook XML is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MathBook XML.  If not, see <http://www.gnu.org/licenses/>.
*********************************************************************-->

<chapter xml:id="Arab_Analysis">
	<title> Attacking the Alphabet </title>
	<introduction>
		<p>In this chapter look at the contributions of Arabic speaking scholars and others mostly to analysis:
			<ul>
				<li> Arabic analysis</li>
				<li> Analysis in the seventeenth century, Falconer</li>
			</ul>
		</p>
	</introduction>
	<section xml:id="arab_attacks">
		<title> Arabic Analysis of the Alphabet</title>
		<p> 
			The following is from <em>al-Kindi's</em><index><main>al-Kindi</main></index> treatise on cryptanalysis written around the year 873 CE.  Try to read through it carefully and then consider the questions which follow it.
		</p>
		<blockquote>
			<p>
				"<alert>Algorithms of Cryptanalysis</alert>
			</p>
			<p>
				So we say, the enciphered letters are either in numerical proportions, that is poetry -because poetic meter, ipso facto, sets measures to the number of letters in each line-, or they are not. Non- poetry can be cryptanalyzed using either quantitative or qualitative expedients.
			</p>
			<p>
				The <alert>quantitative</alert> expedients include determining the most frequently occurring letters in the language in which cryptograms are to be cryptanalyzed. If vowels functioned as the material from which any language is made, and non-vowels functioned as the shape of any language, and since many shapes can be made from the same material, then the number of vowels in any language would be greater than non- vowels. For instance, gold is the material of many shapes of finery and vessels; it may cover crowns, bangles, cups, etc.. The gold in these realizations is more than the shapes made of it. Similarly, the vowels which are the material of any kind of text are more than the non- vowels in any language. I mean by vowels the letters: (a), (y or i or e) and (o or u). Therefore the vowels in any language, inevitably, exceed in number the non-vowels in a text of that language. It happens that in certain languages some vowels are greater in number than some other vowels, while non-vowels may be frequent or scarce according to their usage in each language, such as the letter (s), of which frequency of occurrence is high in Latin.
			</p>
			<p>
				Among the expedients we use in cryptanalyzing a cryptogram if the language is already known, is to acquire a fairly long plaintext in that language, and count the number of each of its letters. We mark the most frequent letter "first", the second most frequent "second", and the following one "third", and so forth until we have covered all its letters. Then we go back to the message we want to cryptanalyze, and classify the different symbols, searching for the most frequent symbol of the cryptogram and we regard it as being the same letter we have marked "first" -in the plaintext-; then we go to the second frequent letter and consider it as being the same letter we have termed "second", and the following one "third", and so on until we exhaust all the symbols used in this cryptogram sought for cryptanalysis.
			</p>
			<p>				
				It could happen sometimes that short cryptograms are encountered, too short to contain all the symbols of the alphabet, and where the order of letter frequency cannot be applied. Indeed the order of letter frequency can normally be applied in long texts, where the scarcity of letters in one part of the text is compensated for by their abundance in another part.
			</p>
			<p>
				Consequently, if the cryptogram was short, then the correlation between the order of letter frequency in it and in that of the language would no longer be reliable, and thereupon you should use another, <alert>qualitative</alert> expedient in cryptanalyzing the letters. It is to detect in the language in which cryptograms are enciphered the associable letters and the dissociable ones. When you discern two of them using the letter order of frequency, you see whether they are associable in that language. If so, you seek each of them elsewhere in the cryptogram, comparing it with the preceding and following dissociable letters by educing from the order of frequency of letters, so as to see whether they are combinable or non-combinable. If you find that all these letters are combinable with that letter, you look for letters combinable with the second letter. If found really combinable, so they are the expected letters suggested by the combination and non-combination of letters, and also by their order of frequency. Those expected letters are correlated with words that make sense. The same procedure is repeated elsewhere in the ciphertext until the whole message is cryptanalyzed." <xref ref="cr_crypt_arabic" detail="vol. 1, pp. 121-123" />
			</p>
		</blockquote>
		<p>
            This is a test!!!!
        </p>
        <sage xml:id="ngram_cell" type="display">
        	<input>
                def ngram_count_simple(text,N=1):
                    ''' if N=1, return a dict containing each letter along with how many times the letter occurred.
                        if N=2, returns a dict containing counts of each bigram (pair of letters)
                        etc.
                        There is an option to remove all spaces and punctuation prior to processing '''
                    text = text.upper()
                    count = {}
                    for i in range(len(text)-N+1):
                        c = text[i:i+N]
                        if c in count: count[c] += 1
                        else: count[c] = 1
                    return [count,len(text)]
                ngram_count_simple("Hello World!!!")
        	</input>
        	<output>
            	[{' ': 1, '!': 3, 'D': 1, 'E': 1, 'H': 1, 'L': 3, 'O': 2, 'R': 1, 'W': 1}, 14]
        	</output>
    	</sage>
    	<sage>
            <input>
            	ngram_count_simple("Hello World!!!")
            </input>
            <output>[{' ': 1, '!': 3, 'D': 1, 'E': 1, 'H': 1, 'L': 3, 'O': 2, 'R': 1, 'W': 1}, 14]</output>
        </sage>
	</section>
	<section xml:id="alberti_attacks">
		<title> Alberti's Approach</title>
		<p> this is a test</p>
	</section>
	<section xml:id="falconer_attacks">
		<title> Falconer's Approach</title>
		<p> this is a test</p>
	</section>

</chapter>